name: "Load & Publish Docker Image"
description: "Load Docker image from artifact and publish to ECR"
inputs:
  image:
    description: "service to build"
    required: true
    default: ""
  tag-prefix:
    description: "tag prefix"
    required: true
    default: ""   
  ecr_aws_access_key_id:
    description: "ecr aws access key id"
    required: true
    default: ""      
  ecr_aws_secret_key:
    description: "ecr aws secret key"
    required: true
    default: "" 
  dockerhub_username:
    description: "dockerhub username"
    required: true
    default: "tazerr"
  dockerhub_pull_token:
    description: "dockerhub pull token"
    required: true
  platforms:
    description: "Platforms to publish (comma-separated, e.g., linux/amd64,linux/arm64)"
    required: false
    default: "linux/amd64,linux/arm64"
  multi_arch:
    description: "Whether to include arm64 (default: false, amd64 only)"
    required: false
    default: "false"
outputs:
  image-tag:
    description: "Pushed image tag"
    value: ${{ env.BUILD_TAG }}

runs:
  using: "composite"
  steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v6
      with:
        aws-access-key-id: ${{ inputs.ecr_aws_access_key_id }}
        aws-secret-access-key: ${{ inputs.ecr_aws_secret_key }}
        aws-region: eu-west-1

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2
      id: login-ecr

    - name: Docker Hub login
      uses: docker/login-action@v3
      with:
        username: ${{ inputs.dockerhub_username }}
        password: ${{ inputs.dockerhub_pull_token }}

    - name: DHI registry login
      uses: docker/login-action@v3
      with:
        registry: dhi.io
        username: ${{ inputs.dockerhub_username }}
        password: ${{ inputs.dockerhub_pull_token }}

    - name: Download amd64 artifact
      uses: actions/download-artifact@v4
      with:
        name: docker-image-${{inputs.image}}${{inputs.tag-prefix}}-linux-amd64
        path: ${{ runner.temp }}/amd64

    - name: Download arm64 artifact
      if: inputs.multi_arch == 'true'
      uses: actions/download-artifact@v4
      with:
        name: docker-image-${{inputs.image}}${{inputs.tag-prefix}}-linux-arm64
        path: ${{ runner.temp }}/arm64

    - name: Set tag
      shell: bash
      env:
        RUN_NUMBER: ${{ github.run_number }}
        START_FROM: ${{ inputs.start-build-from || 0 }}
      run: |
        BUILD_NUMBER=$(($RUN_NUMBER + $START_FROM))
        echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV

    - uses: jwalton/gh-find-current-pr@v1
      id: findPr
      with:
        state: open

    - name: Debug variables
      shell: bash
      run: |
        echo "github.ref: ${{ github.ref }}"
        echo "inputs.tag-prefix: ${{ inputs.tag-prefix }}"
        echo "env.BUILD_NUMBER: ${{ env.BUILD_NUMBER }}"
        echo "steps.findPr.outputs.pr: ${{ steps.findPr.outputs.pr }}"
        echo "Artifacts downloaded:"
        ls -la ${{ runner.temp }}/amd64/ || echo "No amd64 artifacts"
        ls -la ${{ runner.temp }}/arm64/ || echo "No arm64 artifacts"

    - name: Load, tag and push images
      shell: bash
      run: |
        # Determine BUILD_TAG based on git reference
        if [[ "${{ github.ref }}" == "refs/heads/master" || "${{ github.ref }}" == "refs/heads/main" ]]; then
          BUILD_TAG="${{ inputs.tag-prefix }}oneclick-${{ env.BUILD_NUMBER }}"
        elif [[ "${{ github.ref }}" == *"release"* ]]; then
          BUILD_TAG="${{ inputs.tag-prefix }}oneclickrelease-${{ env.BUILD_NUMBER }}"
        elif [[ -n "${{ steps.findPr.outputs.pr }}" ]]; then
          BUILD_TAG="${{ inputs.tag-prefix }}oneclickpr-${{ steps.findPr.outputs.pr }}-${{ env.BUILD_NUMBER }}"
        else
          BUILD_TAG="${{ inputs.tag-prefix }}oneclick-${{ env.BUILD_NUMBER }}"
        fi

        echo "BUILD TAG: ${BUILD_TAG}"
        echo "BUILD_TAG=${BUILD_TAG}" >> $GITHUB_ENV

        REGISTRY="${{ steps.login-ecr.outputs.registry }}"
        IMAGE_NAME="${{inputs.image}}"
        FULL_IMAGE="${REGISTRY}/${IMAGE_NAME}:${BUILD_TAG}"
        MULTI_ARCH="${{ inputs.multi_arch }}"

        # Load and push amd64 image
        echo "Loading amd64 image..."
        docker load --input ${{ runner.temp }}/amd64/image${{inputs.tag-prefix}}-linux-amd64.tar

        # Get the loaded image name and retag for amd64
        LOADED_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | head -1)
        echo "Loaded image: ${LOADED_IMAGE}"

        AMD64_TAG="${FULL_IMAGE}-amd64"
        docker tag "${LOADED_IMAGE}" "${AMD64_TAG}"
        echo "Pushing ${AMD64_TAG}..."
        docker push "${AMD64_TAG}"

        # Load and push arm64 image if multi_arch is enabled
        if [[ "$MULTI_ARCH" == "true" ]]; then
          echo "Loading arm64 image..."
          docker load --input ${{ runner.temp }}/arm64/image${{inputs.tag-prefix}}-linux-arm64.tar

          # Get the loaded image name and retag for arm64
          LOADED_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "${AMD64_TAG}" | head -1)
          echo "Loaded image: ${LOADED_IMAGE}"

          ARM64_TAG="${FULL_IMAGE}-arm64"
          docker tag "${LOADED_IMAGE}" "${ARM64_TAG}"
          echo "Pushing ${ARM64_TAG}..."
          docker push "${ARM64_TAG}"
        fi

        # Create and push manifest
        echo "Creating manifest..."
        if [[ "$MULTI_ARCH" == "true" ]]; then
          docker manifest create "${FULL_IMAGE}" \
            "${AMD64_TAG}" \
            "${ARM64_TAG}"
          docker manifest annotate "${FULL_IMAGE}" "${AMD64_TAG}" --os linux --arch amd64
          docker manifest annotate "${FULL_IMAGE}" "${ARM64_TAG}" --os linux --arch arm64
        else
          docker manifest create "${FULL_IMAGE}" \
            "${AMD64_TAG}"
          docker manifest annotate "${FULL_IMAGE}" "${AMD64_TAG}" --os linux --arch amd64
        fi

        echo "Pushing manifest..."
        docker manifest push "${FULL_IMAGE}"

        echo "Successfully pushed image: ${FULL_IMAGE}"
        docker manifest inspect "${FULL_IMAGE}"